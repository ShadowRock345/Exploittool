import os
import scapy.layers.dot11
from sys import platform
import utils.modulemanager as md
from scapy.all import *
import pandas
import time
import os
from threading import Thread
from threading import Event
import multiprocessing
from utils import checklibraries
from py_console import console, bgColor, textColor


class Main(md.Module):
    """Module for Scanning for available Wifi"""
    parameters = {"device": "wlan0", "device_monitor": "wlan0mon", "channel": "1", "change_channel": "False"}
    completions = list(parameters.keys())

    networks = pandas.DataFrame(columns=["BSSID", "SSID", "Signal_strength", "Channel", "Crypto"])
    networks.set_index("BSSID", inplace=True)
    queue = multiprocessing.Queue()
    def callback(self, packet):
        if packet.haslayer(scapy.layers.dot11.Dot11Beacon) or packet.haslayer(scapy.layers.dot11.Dot11ProbeResp):
            if packet.type == 0 and packet.subtype == 8:
                bssid = packet[scapy.layers.dot11.Dot11].addr2

                ssid = packet[scapy.layers.dot11.Dot11Elt].info.decode()

                try:
                    dbm_signal = packet.dBm_AntSignal
                except:
                    dbm_signal = "N/A"

                stats = packet[scapy.layers.dot11.Dot11Beacon].network_stats()

                channel = stats.get("channel")

                crypto = stats.get("crypto")

                self.networks.loc[bssid] = (ssid, dbm_signal, channel, crypto)
                self.queue.put(self.networks)

    def executecomm(self,interface,ch):
        os.system(f"sudo iwconfig {interface} channel {ch}")

    def changechannel(self):
        ch = int(self.parameters['channel'])
        pool = multiprocessing.Pool(1)
        while True:
            interface = self.parameters['device_monitor']
            pool.apply_async(self.executecomm, (interface,ch,))

            ch = ch % 14 + 1
            time.sleep(0.5)
            pool.close()

    def printresults(self,q):
        while True:
            if platform == "linux":
                os.system("clear")
            if platform == "win32":
                os.system("cls")
            net = q.get()
            console.log(net)
            time.sleep(0.5)

    def do_exploit(self, line):
        console.log("Putting network Adapter into monitoring mode.")
        console.log("\n")
        interface = self.parameters['device_monitor']
        ch = int(self.parameters['channel'])
        os.system("sudo airmon-ng check kill")
        os.system("sudo ifconfig wlan0 down")
        os.system("sudo iwconfig wlan0 mode monitor")
        os.system("sudo ifconfig wlan0 up")
        os.system(f"sudo iwconfig {interface} channel {ch}")
        # os.system("airmon-ng start " + self.parameters['device'])
        # os.system("iwconfig")
        console.log("\n")
        stop_event = Event()

        try:
            change_channel = self.parameters['change_channel']
            #printer = Thread(target=self.printresults,args=(stop_event,),name="Resultprinter")
            #printer.daemon = True
            #printer.start()
            printer = multiprocessing.Process(target=self.printresults, args=(self.queue,))
            printer.start()
            if change_channel == "True":
                #changer = Thread(target=self.changechannel,args=(stop_event,),name="Channelchanger")
                #changer.daemon = True
                #changer.start()
                changer = multiprocessing.Process(target=self.changechannel, args=())
                changer.start()
            sniff(prn=self.callback, iface=interface)
        except KeyboardInterrupt:
            console.info("To stop double press ctr+c")
            stop_event.set()
            #printer.join()
            printer.terminate()
            if change_channel == "True":
                #changer.join()
                changer.terminate()

def complete_set(self, text, line, begidx, endidx):
    splitline = line.partition(' ')[2]
    offs = len(splitline) - len(text)
    return [s[offs:] for s in self.completions if s.startswith(splitline)]
